\chapter{Arbeitsbericht}
%
\section{1. Woche}
%
\subsection{Wochenübersicht}
%
Tabelle
%
\subsection{Beschreibung}
%
Am ersten Tag meiner Tätigkeit bei Vector Informatik bekam ich die Gelegenheit die Firma und ihre unterschiedlichen Abteilungen näher kennen zu lernen. Es war erforderlich, an einer ausführlichen Präsentation über die Firma und die unterschiedlichen Abteilungen teilzunehmen. Dabei konnte ich ebenfalls Mitarbeiter kennen lernen, für die dieser auch ihr erster Tag bei Vector war.
%
\begin{figure}[htp]
\centering
%\def\svgwidth{scale=0.4}
%\input{./Bilder/Zeichnung1.pdf_tex}
\includegraphics[scale=1]{./Bilder/Zeichnung1.pdf}
\caption{Zeichnung1}
\label{fig:Zeichnung1}
\end{figure}

Die Softwareabteilung (ADP) gab uns u.a. zahlreiche Einblicke in Themen wie vorhandene Software-Packete, Software-Sicherheit und den richtigen Umgang mit den von Vector zur Verfügung gestellten Programmen und Anwendungen. 

Mein interner Betreuer, der Herr Dipl. Ing. Markus Schwarz, stellte mir eine die Abteilung vor und begleitete mich an meinen Arbeitsplatz.

Während der ersten Tagen galt meine Arbeit der Einarbeitung und Verwendung mancher Software Tools, die von jedem Vector-Mitarbeiter zu verwenden sind. Unter anderem wird dabei eine eigene Umgebung verwendet, um die Arbeitsstunden zu dokumentieren. Diese ist in Bild \ref{fig:viTime} beispielhaft zu sehen.
%
\begin{figure}[!htp]
\centering
\includegraphics[scale=0.5]{./Bilder/vi.pdf}
\caption{viTime}
\label{fig:viTime}
\end{figure}
%

In den folgenden Tagen wurde mir die 1. Aufgabe meiner Arbeitstätigkeit bei Vector vorgestellt. Diese bestand darin, mich mit den Konzepten des MISRA-C-Kodierungsstandards vertraut zu machen. Eine kurze Einführung wird im folgenden Unterkapitel gegeben.
%
%\subsection*{MISRA C}
\paragraph{MISRA C}
%
MISRA-C hat seinen Ursprung in der Automobilindustrie. Er wurde durch die britische \glqq The Motor Industry Sofrware Reliability Association\grqq\ eingeführt, um den ersten Standard für die Programmiersprache C zu definieren. Letzterer wurde zum ersten Mal in 1998 mit dem Ziel veröffentlich, eine positive Auswirkung auf die Verwendung von Software innerhalb der britischen Automobilindustrie zu haben~\cite{MISRA2004}. Seit seiner ersten Einführung hat sich der MISRA-Standard nicht nur im Automobilsektor durchgesetzt sondern auch u.a. in der Raumfahrtindustrie und Medizintechnik. 

Eine Vielzahl an Regeln sind dabei veröffentlicht worden, um robusteren und zuverlässigeren Embedded C-Code für Steuergeräte zu produzieren. Außerdem wird damit erreicht, dass die erstellten Software-Produkte wiederverwendbar und portabler sind. 

Die Anwender dieser Richtlinien auf ihre Produkte konnten außer der erwähnten Vorteile einige Verbesserungsvorschläge treffen, die manchen Nachteilen beim Einsatz des MISRA-Standards entgegenwirken sollen. Aus diesem Grund entschloss sich die MISRA-Arbeitsgruppe weitere Ausgaben zu veröffentlichen, welche jeweils in den Jahren 2004 bzw. 2012 erschienen sind.

Bei Vector Informatik GmbH wird zur Zeit die Version des Kodierungsstandards eingesetz, die im Jahr 2004 verabschiedet wurde~\cite{MISRACodeMetric}. Die Kodierungsstandards von Vector Informatik richten sich momentan noch nicht nach der am 18. März 2013 genannte 2012 MISRA-Version, da die Mehrheit der Regeln umnummeriert und umstrukturiert wurden. Das bedeutet, dass ein Umstieg von der letzten MISRA-C:2004-Version auf die aktuelle Version nicht vollständig automatisiert umzusetzen ist.
%

%
\begin{figure}[!htp]
\centering
\includegraphics[scale=0.1]{./Bilder/MISRAoverall.png}
\caption{MISRA: wenn ich dieses Bild nicht verstehen kann, dann lieber weglassen}
\label{fig:MISRA}
\end{figure}
%

%
%\subsection*{Erste Aufgabenstellung}
\paragraph{Erste Aufgabenstellung}
%
Vektor und somit die Abteilung PES sind aus diesem Grund darauf angewiesen, einen Umstieg in die neue Version zu ermöglichen. Da dies sich nicht ohne großen Aufwand umsetzen lässt, muss dazu muss eine detaillierte Analyse vor allem über die Kompatibilität zwischen den beiden Versionen durchgeführt werden.
Hier soll eine ausführliche Erklärung über die Aufgabe angegeben werden, bei der Vergleich der beiden MISRA-Versionen durchgeführt wird.(Hier Beschriebung von Zeugnis, welches Markus erstellt hat)
%
\section{2. Woche}
%
\subsection{Wochenübersicht}
%
Tabelle
%
\subsection{Beschreibung}
%
%\subsection*{Durchführung der ersten Aufgabenstellung}
\paragraph{Durchführung der ersten Aufgabenstellung}
%
Eine genaue Rechnerche über die oben erwähnten Standards ist notwendig gewesen, um nicht nur einen Einblick in das Thema zu gewinnen sondern auch die technischen Zusammenhänge zu verstehen.

Im Folgenden wird eine kurze Einführung in die neuen Features angegeben, die von der MISRA C:2012-Version unterstützt werden und wie letztere strukturiert ist.
%
\subparagraph{MISRA C:2012}
%
Im Gegensatz zu der Vorversion fordert MISRA C:2012, dass Code dem Standard \textsc{C99} \footnote{ISO Standard for the C language ISO/IEC 9899:1999~\cite{MISRA2012}} entspricht. Dabei sind einige neue Regeln hinzugekommen, die sich hauptsächlich auf \textsc{C99} beziehen, einige wenige wurden umformuliert oder sogar entfernt~\cite{WarMISRAC}.
Der zahlreiche Einsatz der MISRA C:2004 über die Jahre hat vielfältige Ergänzungen und Verbesserungen als Folge gehabt. Die Regeln sind jetzt klarer definiert und beschrieben, wobei verbesserte Begründungen für ihre Nutzung angegeben werden.

Die einzelnen Regeln bestehen jetzt aus mehreren Teilen:

\begin{itemize}
\item Erweiterte Erläuterungen (Amplification): \\
umfangreichere Beschreibeung der betrachteten Richtlinie.
\item Begründung (Rationale): \\
Erläuterung, warum die Regel benötigt wird.
\item Ausnahmen (Exceptions): \\
Beschreibung der Fälle, bei denen die betrachtete Regel nicht gilt.
\item Beispiele (Examples): \\
Beispiele, wie man die Regel anwenden kann.
\end{itemize}

Bei den ersten MISRA-Versionen sind die Regeln in zwei Kategorien eingeteilt: 
notwendige (required) und empfohlene (advisory) Regel. Die ersten sind zwingend erforderliche Anforderungen an dem Programmierer. Die empfohlenen Regeln können im Gegensatz dazu eingehalten werden, müssen aber nicht.

\textsc{MISRA C:2012} hat eine zusätzliche Kategorie eigeführt: 

Meine Tätigkeiten bestanden vorwiegend darin, die richtigen Einstellungen zur statischen Code-Analyse einer in der Abteilung erstellten eingebetteten Beispiel-Anwendung durchzuführen. Die Analyse sollte mit Hilfe der Version 7.0 der Analyse-Software QAC erfolgen, deren Funktionalität im Beschreibungskapitel der 1. Woche angegeben wird (Dokoment QAC User Guide verwenden). Diese Version wird momentan in Vector angewendet.
Die folgende Graphik zeigt einen Überblick über die funktionalen Beziehungen der Analyse-Software und die unterschiedlichen Ergebnisse einer beliebigen Beispielanwendung.
%
%
\begin{figure}[!htp]
\centering
\includegraphics[scale=0.7]{./Bilder/QAC.pdf}
\caption{QAC}
\label{fig:MISRA}
\end{figure}
%
\begin{figure}[!htp]
\centering
\includegraphics[scale=1]{./Bilder/QAC1.pdf}
\caption{QAC}
\label{fig:QAC1}
\end{figure}
%

Es ist notwendig richtige Einstellungen für jedes QAC-Projekt durchzuführen, welches der Struktur eines entsprechenden Entwicklungsprojekt wiederspiegelt. Ein entsprechendes Projekt beinhaltet ein oder mehrere Ordner, Quellcode-Dateien bzw. Einstellungsinformationen, die als personalities bezeichnet werden.
In den personalities werden laut application note jeweils folgende Einstellungen durchgeführt:
...... Beschreibung der einzelnen Files ($*.p_a, *.p_c, *.p_s$).

Inerhalb der Datei $*.p_c$ musste ich die Definition $_WIN32_WINNT$ anpassen, da auf dem Computer, auf dem die statische Codeanalyse durchgeführt werden soll, ein 64-bit-Betriebssystem läuft. Somit sollen manche Makros angepasst oder sogar außer Betracht gelassen werden .
%
\begin{figure}[!htp]
\centering
\includegraphics[scale=1]{./Bilder/QAC2.pdf}
\caption{QAC}
\label{fig:QAC2}
\end{figure}
%

Nachdem die richtigen Einstellungen für das Projekt ausgewählt und vorgenommen wurden, haben die ersten Analysen stattgefunden, welche Hinweise auf eventuell fehlerhafte Teile beim Code ausgaben.
%

\begin{figure}[!htp]
\centering
\includegraphics[scale=1]{./Bilder/QAC3.pdf}
\caption{QAC}
\label{fig:QAC3}
\end{figure}
%
Bei Vector werden unterschiedliche Programme eingesetzt, welche von jedem Mitarbeiter beherrscht werden sollen und u.a. Informationen über die Arbeitstätigkeit in der Firma der Personalabteilung weiterleiten.
Diese sind unter anderem (diese Version richtet sich nach den Richtlinien der Universität. In der Version von Vector muss ich eine richtige Themengliederung angeben. Ein richtiger Bericht muss es werden):
TortoiseSVN: Hier bitte eine kurze Beschreibung von Tortoise geben. Du kannst auch dazu irgendeine Präsentation von ADP benutzen, suche im Intranet danach. 
%
\begin{figure}[htp]
\centering
\includegraphics[scale=1]{./Bilder/Repo.pdf}
\caption{Tortoisegit}
\label{fig:Tortoisegit}
\end{figure}
%
\section{Dritte Woche}
%
\subsection{Wochenübersicht}
%
Tabelle
%
\subsection{Arbeitsbericht}
%
Während der dritten Woche im Unternehmen bekam ich den Auftrag, die release notes vom QAC Programm zu sammeln und untereinander zu vergleichen. Das Ziel war dabei, die Unterschiede zwischen der aktuell der PES-Abteilung zur Verfügung stehenden QAC-Version 7.0 und den höheren Versionen des verwendeten Programms festzustellen. Es war somit notwendig eine Methodik auszuwählen, um die genannten Unterschiede darzustellen. 
Es hat sich dementsprechend als sinnvoll erwiesen eine Excel-Tabelle zu erstellen, damit sich jeder einen möglichst guten Überblick über das Thema verschafft. Die Struktur der genannten Tabelle, welche in Abbildung \ref{fig:QAC4} zu sehen ist, stellt idealerweise einen Teil der Entwicklungslinie der neuen QAC-Versionen. Insgesamt sind 6150 Nachrichten behandelt worden, die innerhalb des Entwicklungsprozesses der statischen QAC-Analysesoftware eingeführt worden sind. Unter diesen Nachrichten befinden sich jedoch auch welche, die gelöscht, angepasst oder völlig umgeschrieben wurden. Dementsprechend würde sich ohne eine geeignete Methode nur schwer erkennen lassen, welche relevanten Modifikationen die Analysesoftware erfahren hat.

\begin{figure}[!htp]
\centering
\includegraphics[scale=1]{./Bilder/QAC4.pdf}
\caption{QAC}
\label{fig:QAC4}
\end{figure}

Bei der Untersuchung musste ich überprüfen...

Danach war es notwendig, nach dem Neuerwerb der QAC Version 9.0 für eine kleine Anzahl an Sourcecode (simple component) ein QAC-Projekt zu erstellen und deren Einstellungen anzupassen. Gleichzeitig war es notwendig, die Quelldateien mit der QAC Version 7.0 zu analysieren, um zu untersuchen, welche Änderungen vorkommen und was gleich geblieben ist. Folgende Tabelle wurde erstellt, beschreiben...

\begin{figure}[!htp]
\centering
\includegraphics[scale=1]{./Bilder/QAC5.pdf}
\caption{QAC}
\label{fig:QAC5}
\end{figure}
%
\section{Vierte Woche}
%
\subsection{Wochenübersicht}
%
Tabelle
%
\subsection{Arbeitsbericht}
%
Während der 4. Woche musste ich mich mit den weiteren Einstellungen eines QAC-Projekts beschäfitgen. Diesmal handelte es sich um ein relativ umfanreicheres Projekt, so dass es aufwendiger war, die Konfigurationsdateien anzupassen. 
Das Ziel war, beide Versionen am Beispiel eines umfangreicheres Projekt zu analysieren. Dieses bestand aus einer großen Anzahl an Quellcode.
Die zu analysierende Dateien mussten in ein bestimmtes Verzeichnis übertragen werden, wobei sich diese ursprünglich zur besseren Übersicht  für den Kunden in sehr vielen Unterodner organisiert waren. Dies hat dazu geführt, dass ich mir eine Methode aussuche, um die Dateien nicht einzeln und per Hand in die Zieladressen zu kopieren. Es hat sich somit als sinnvoll erwiesen, eine dazu geeignete Programmiersprache zu verwenden, die mir diese Aufgabe erleichterte. Ich konnte feststellen, dass sich zum Lösen u.a. der genannten Aufgabe einige Skriptsprachen wie Perl oder Python eignen. Da bisher in der Abteilung die Mitarbeiter meistens mit Perl große Projekte erstellten und somit große Erfahrung dabei haben, habe ich mit entschieden Perl einzusetzen.

\begin{figure}[!htp]
\centering
\includegraphics[scale=1]{./Bilder/QAC6.pdf}
\caption{QAC}
\label{fig:QAC6}
\end{figure}

Die Übertragung der Dateien war nicht die einzige Aufgabe, die zum Erstellen des QAC 9.0-Projektes durchgeführt werden musste. Es war außerdem notwendig die Pfade der einzelnen zu analysierenden Dateien anzugeben. Wie im Bild XX zu erkennen ist, bedient sich QAC9.0 einer XML-Konfigurationsdatei, aus der das Programm nicht nur die Pfade der Dateien entnimmt, sondern auch weitere wichtige Einstellungen, die im Prinzip sich auch über die GUI angeben lassen. Diese Methode bzw. die XML-Datei zu bearbeiten, ist jedoch hilfreich, um das Aufrufen des Programms implizit beispielsweise über die Console zu ermöglichen. Dies wird in einem späteren Szenario meiner Tätigkeit nötig sein, damit man eine statische Code-Analyse für die verschiedene Abteilungen automatisieren und somit vereinfachen kann. 

\begin{figure}[!htp]
\centering
\includegraphics[scale=1]{./Bilder/QAC7.pdf}
\caption{QAC}
\label{fig:QAC7}
\end{figure}

\begin{figure}[!htp]
\centering
\includegraphics[scale=1]{./Bilder/QAC8.pdf}
\caption{QAC}
\label{fig:QAC8}
\end{figure}
%
\section{Fünfte Woche}
%
\subsection{Wochenübersicht}
%
Tabelle
%
\subsection{Arbeitsbericht}
%
Nachdem die Einstellungen für das oben erwähnte Projekt durchgeführt worden sind, lässt sich die statische Codeanalyse mit Hilfe der neuen QAC-Version (9.0) durchführen. Es muss dabei untersucht werden, inwiefern die aktuellen Projekte sich mit Hilfe der neuen QAC-Version analysieren lassen, ohne dass dabei beispielsweise eine große Menge von falsch positiven bzw. negativen Nachrichten ausgegeben werden.

Eine Möglichkeit, dies zu realisieren, besteht darin, ein mit Hilfe der 7.0-QAC-Version bereits analysiertes Projekt ebenfalls mit Hilfe der 9.0-QAC-Version zu analysieren und anschließend die entsprechende Reports zu miteinander zu vergleichen.
%
\section{Sexte Woche}
%
\subsection{Wochenübersicht}
%
Tabelle
%
\subsection{Arbeitsbericht}
%
Die Aufgabe der letzten Woche musste fortgesetzt werden. Die Daten aus den Analyseergebnissen mussten extrahiert werden. Einerseits wird dies vom QAC-Programm selbst dadurch erledigt, dass in Form von *.xml-Dateien die verschiedenen verletzten MISRA-Regel bzw. QAC-Warnungen ausgegeben werden. Diese Form der Datendarstellung ist für die Datenübertragung geeignet, jedoch nicht dafür, dass Trends und Zusammenhänge erkannt werden. Diese Daten müssen erstmal extrahiert und so bearbeitet werden, dass ein Mensch diese verstehen und verwenden kann.

Eine *.xml-Datei lässt sich mit Hilfe einer xslt-Transormation so bearbeiten, dass die enthaltenen Daten als eine Tabelle und beispielsweise als eine *.txt-Datei dargestellt werden kann. (Hierbei muss ich eine genaue Beschreibung der XSLT-Transformation angeben)

Eine Art, die Daten besser darzustellen sind Excel-Tabellen, wie in der unteren Tabelle zu erkennen ist. Die in den beschriebenen *.xml-Dateien enthaltenen Daten können dadurch besser miteinander vergliechen werden.

Ich musste auch anfangen, mich mit den qacli-Befehlen zu beschäftigen, da diese auch eine wichtige Rolle spielen, wenn man über die Konsole eine automatische statische Analyse ermöglichen möchte. (Hier sollte ich versuchen, Markus Bilder wiederzugeben). Die wichtigsten QACLI befehle auch hier angeben.

Als letztes habe ich die erstellten PERL- bzw. Batch-Dateien zum Aufrufen letzterer in dem Netzwerkordner gespeichert! 
%
\section{Siebte Woche}
%
\subsection{Wochenübersicht}
%
Tabelle
%
\subsection{Arbeitsbericht}
%
Markus hat mir am Dienstag (Montag war ja Feiertag) die zweite Aufgabe vorgestellt. Dabei handelte es sich um das Modifizieren bzw. das Anpassen eines Frameworks zum automatisierten Testen von Software-Module. Ein sogenanntes Basic Test Environment (BTE) gehört zu dem genannten Testframework (Bilder hinzufügen), welches hardware unabhängig Software-Komponenten auf einem beliebigen PC testet. Bei den Tests werden wie in der Abbildung gezeigt von der BTE Nachrichten aus den Testergebnissen erstellt und in verschiedenen Report-Dateien aufgelegt. Auf diese Art und Weise kann der Software-Tester oder der Anwender einfacher überprüfen, in welchen Stellen des getesteten Codes es fehlerhafte Module gibt oder Warnungen auftauchen.

Zu meiner Aufgabe gehört, diese Möglichkeit so zu erweitern, dass die BTE auch auf einer beliebigen Hardware läuft, d.h. hardwareunabhängig, wobei die Möglichkeit geboten sein muss, entsprechende Reports zu erstellen. Die Reports können in diesem Fall nicht mehr als entsprechende Dateien auf dem Rechner abgelegt werden, viel mehr muss eine Methode  gefunden werden, wie der Report auf der RAM temporär zu speichern ist.
%
\section{Achte Woche}
%
\subsection{Wochenübersicht}
%
Tabelle
%
\subsection{Arbeitsbericht}
%
In der BTE Software sind Methoden (sprintf, printf) verwendet, die die formatierte Ein- und Ausgabe von Strings ermöglichen. Zudem werden Methodenaufrufe wie fprintf oder fopen eingesetzt, die der Umgang mit Streams bzw. die Erstellung einer Datei ermöglichen.

Zwei Mögichkeiten können betrachtet werden, um mit den knappen Softwareressourcen der Embedded Platform umzugehen:

\begin{itemize}
\item Man bindet entsprechende Ersatzbibliotheken ein, bei denen der Verbrauch der Ressouercen in Grenzen gehalten wird.
\item Man bietet dem Anwender die Möglichkeit an, durch entsprechende Routinen diejenigen Teile vom Code beim Kompiliervorgang auszublenden, die nicht einzusetzen sind.
\end{itemize}

Die zweite Lösung wird so angewendet, dass die nicht kompatiblen Codestellen mit vorhandenen und zusätzlich eingebauten Präprozessor-Direktiven \lstinline$#define$\ \grqq auskommentiert\glqq werden.

XXX Bild zur Architektur des Reports, welches auf der RAM gespeichert wird. 

Die Stellen vom Speicher, wo die zu interessierenden Daten der durchgeführten Tests zum Erstellen eines Reports abgelegt wurden, lassen sich mit Hilfe eines memory mapping des entsprechenden Prozessors analysieren. Dies ist mit einem Debugger möglich und kann bestenfalls als binary file ausgegeben werden. Das ist die Beschreibung des Ansatzs, welcher von Markus und Timo erklärt worden ist.

Ein Ansatz, um aus den binary files ein Report zu erstellen, ist, das binary File mit Hilfe einer Skriptsprache zu analysieren, damit das ursprungliche von der BTE auf dem PC erzeugte Report erneut ausgegeben werden kann. Die genaue Darstellung des Perl-Scripts (Perl-Listing) kann im Anhang \ref{cha:tools} gefunden werden. 

Die erzielten Lerneffekte sind vor allem der Umgang mit einer Skriptsprache, das Speicherplatz sparend Codieren in C.
%
\section{Neunte Woche}
%
\subsection{Wochenübersicht}
%
Tabelle
%
\subsection{Arbeitsbericht}
%
Da die Reports auf einer beliebigen Hardware zu implementieren sind, sollte eine bestimmte Hardware ausgesucht werden. Die Hardware die mir vorgestellt wurde, war das STM32F4-Entwicklungsboard. Mit dieser Hardware habe ich in der Vergangenheit schon zu tun gehabt, deswegen konnte ich ohne große Mühe die Einstellungen vornehmen, um ein Projekt zu starten.

Das genannte Board lässt sich über ST-Link-Treiber flaschen , welcher vom Hersteller zur Verfügung gestellt wird.
%
\begin{figure}[!htp]
\centering
\includegraphics[angle=90,scale=0.5]{./Bilder/eclipsegit.pdf}
\caption{eclipsegit}
\label{fig:eclipsegit}
\end{figure}
%
Der auf dem Mikrocontroller erzeugte Report sollte auf einer Speicher sparenden Art und Weise erstellt werden. Man hat sich 2 Möglichkeiten überlegt, wie dies geschehen soll. Letzteres wird im Folgenden Bild wiedergeben:

%Bild hier angeben%

Zu der Erkenntnis konnte man gelagen, dass die zweite Möglichkeit besser geeinet ist und auf einer seriellen Übertragung der Daten basiert.
%
\section{Zehnte Woche}
%
\subsection{Wochenübersicht}
%
Tabelle
%
\subsection{Arbeitsbericht}
%
In der vorliegenden Woche war meine Aufgabe das Perl Programm zu pflegen und ein wenig besser zu strukturieren. Außerdem wurde mir erklärt, dass die Messages, die über die BTE durchgeschaltet, jedoch nicht in die LogListe registriert werden, auch in dem Report vorkommen sollten. Dies geschieht auch bei einem normalen Report, welcher bei einem Test auf dem Computer erzeugt wird. Dies musste ebenfalls im Programm implementiert werden. 

Die aktuelle Version meiner Anwendung erzeugt das auf dem linken Teil gezeigtem File im xml-Format. Das rechts davon gezeigte File ist das Report, welcher wie bereits oben erwähnt bei einem Test auf dem Computer erzeugt wird. Die Unterschiede lassen sich dadurch erklären, dass manche Features, die im auf dem Computer erstellten Report in dem auf der RAM gespeicherten Report nicht relevant sind und somit nicht darzustellen sind. 
%
\begin{figure}[!htp]
\centering
\includegraphics[angle=90,scale=0.45]{./Bilder/reports.pdf}
\caption{reports}
\label{fig:reports}
\end{figure}
%
Das Bild zum UML Statechart sollte ich mal einfügen und von Markus checken lassen und endgültig hier einfügen.

Am Ende erfogte eine Abgabe der letzten Version meiner programmierten PERL-Anwendung abgegeben werden. Markus hat manche Korrekturen und Verbesserungen durcgeführt und mir dann diesbezüglich Rückmeldung gegeben.
%
\section{Elfte Woche}
%
\subsection{Wochenübersicht}
%
Tabelle
%
\subsection{Arbeitsbericht}
%
Diese Woche wurde mir die dritte Aufgabe vorgestellt. Dabei ginge es darum mich mit der Arduino Anwendung und der Einstellung eines geeigneten SCI-Treiber zu beschäftigen. Die Programmierung von Win32-Anwendungen ist nicht trivial, dabei ist man auf die Verwendung von Funktionen angewiesen, die von Windows zur Verfügung gestellt werden. 

Hierbei beschreiben, was Win32 ist und wieso ich nicht andere Module verwenden könnte.

Dabei hat die Programmierung der SCI-Anwendung in VS erfolgt, ich habe mich entschieden das Arduino Projekt nicht wie Andreas vorgeschlagen hat, sondern in AtmelStudio umzusetzen. Die Atmelstudio Anwendung und die Einstellung eines Projektes mit den external configurations beschreiben.

Der programmierte Win32-Treiber arbeitet so, dass die aufzurufende Funktion so lange wartet bis die aufgerufene feritg ist.(waiting rendezvous) nach ~\cite{HardTime}. Die dabei verwendete Methode(...) arbeitet als \grqq timed rendezvous \glqq, wartet also nur eine bestimmte Zeit bis benötigte Task antwortet, ansonsten bricht sie ihren Methodenaufruf ab.