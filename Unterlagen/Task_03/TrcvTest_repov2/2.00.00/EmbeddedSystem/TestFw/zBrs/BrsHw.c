/*  *****   STARTSINGLE_OF_MULTIPLE_COMMENT    *****  */




/*****************************************************************************/
/**
 * @file    BrsHW.C
 * @brief   Basic Runtime System, HW specific file, Code
 *          This file encapsulates all hardware specific functions from the user.
 *          This includes management of common functions like power and PLL control,
 *          board specific LED and key support and management of used ports and the
 *          generation of the 1ms time base interrupt.
 *           
 *          This file supports osCAN with CANoe; Compiler is Visual C++
 *
 * @attention Please note:
 *  The demo and example program only shows special aspects of the software. 
 *  With regard to the fact that this program is meant for demonstration purposes 
 *  Vector Informatik´s liability shall be expressly excluded in cases of 
 *  ordinary negligence, to the extent admissible by law or statute. 
 *
 *****************************************************************************
 *               C O P Y R I G H T
 *****************************************************************************
 * Copyright (c) 2004 by Vector Informatik GmbH.      All rights reserved.
 *
 *                    Alle Rechte an der Software verbleiben bei der
 *                    Vector Informatik GmbH.
 *                    Vector Informatik GmbH räumt dem Lizenznehmer das unwider-
 *                    rufliche, geographisch und zeitlich nicht beschränkte,
 *                    jedoch nicht ausschließliche Nutzungsrecht innerhalb des
 *                    Lizenznehmers ein. Die Weitergabe des Nutzungsrechts
 *                    durch den Lizenznehmers ist auf dessen Zulieferer
 *                    beschränkt. Die Zulieferer sind zu verpflichten, die
 *                    Software nur im Rahmen von Projekten für den Lizenznehmer
 *                    zu verwenden; weitere Rechte der Zulieferer sind
 *                    auszuschließen.
 *****************************************************************************
 * @author       A U T H O R   I D E N T I T Y
 *****************************************************************************
 - Initials     Name                      Company
 - ********     *********************     ************************************
 - Ra           Andreas Raisch            Vector Informatik GmbH
 - Uf           Ulrich Frank              Vector Informatik GmbH
 - Get          Matthias Gette            Vector Informatik GmbH
 - Mas          Markus Schwarz            Vector Informatik GmbH
 - Bir          Holger Birke              Vector Informatik GmbH
 - Ms           Gunnar Meiss              Vector Informatik GmbH
 *****************************************************************************
 * @version     R E V I S I O N   H I S T O R Y
 *****************************************************************************
 - Date         Version Author  Description
 - **********   ******* ******  ************************************
 - 2002-08-14   1.00.00 Ra      First Version
 - 2003-04-04   1.01.00 Uf      ESCAN00005328: Changed call to BrsMainExc.
 - 2003-07-23   1.02.00 Uf      Changed transceiver handling (high level functions
                                are now in BrsStaMa.c, port functions in BrsHw.c
 - 2003-10-06   1.03.00 Get     comments reformatted according to doxygen style
 - 2004-02-10   1.04.00 Get     Hint added for BullsEye bug
 - 2004-11-26   1.05.00 Ra      Comments and structure reworked for DoxyGen
 - 2005-01-18   1.06.00 Ra      CANoe/osCAN checks added
 - 2005-01-18   1.06.01 Uf      can_inc.h included if CAN is active
 - 2005-04-06   1.06.02 Uf      extern declaration of CanBusName added
 - 2005-07-01   1.06.03 Bir     Added BrsHwSoftwareResetECU
 - 2005-07-25   1.06.04 Uf      removed multiple defines               
 - 2006-11-02   1.06.05 Ms      Added AUTOSAR support
 - 2007-04-03   1.06.06 Ms      Updated AUTOSAR support
 *****************************************************************************/

/*****************************************************************************
 * Include the files necessary for the Basic Runtime System (BRS)
 *****************************************************************************/

/*
 * Description: The BrsCfg header is used to configure different types of
 *              tests and system setups. Therefore it must be included first
 *              in each BRS and test module.
 *              This file is part of the BRS.
 */
#if defined( C_KOMMENTAR_VECTOR )
 /* CANbedded developers: This include is hardware independent and must not be changed. */
#endif
#include "BrsCfg.H"

/*
 * Description: The V_Cfg header is generated by the generation tool. Important 
 *              information like CPU and compiler type, manufacturer information
 *              and a list of currently used CANbedded modules is defined here.
 */
#if defined( C_KOMMENTAR_VECTOR )
 /* CANbedded developers: This include is hardware independent and must not be changed. */
#endif
#include "V_Cfg.H"

/*
 * Description: The V_Def header provides types and definitions common to all 
 *              VECTOR CANbedded modules.
 */
#if defined( C_KOMMENTAR_VECTOR )
 /* CANbedded developers: This include is hardware independent and must not be changed. */
#endif
#include "V_Def.H"

/*
 * Description: The BrsHW header provides all the necessary interfaces to
 *              the micros hardware features like ports, timers, LEDs, ... 
 *              This file is part of the BRS.
 */
#if defined( C_KOMMENTAR_VECTOR )
 /* CANbedded developers: This include is hardware independent and must not be changed. */
#endif
#include "BrsHW.H"

/*
 * Description: The BrsMain header provides all the necessary interfaces to
 *              the BRS main file.
 *              This file is part of the BRS.
 */
#if defined( C_KOMMENTAR_VECTOR )
 /* CANbedded developers: This include is hardware independent and must not be changed. */
#endif
#include "BrsMain.H"

#if defined( BRS_ENABLE_TESTADDON )
/*
 * Description: The BrsAddOn header provides all the necessary interfaces to
 *              the test support add on module. Please refer to the BrsAddOn
 *              module for details of the supported add on's.
 *              This file is part of the BRS.
 */
#if defined( C_KOMMENTAR_VECTOR )
 /* CANbedded developers: This include is hardware independent and must not be changed. */
#endif
#include "BrsAddOn.H"
#endif

#if !defined( BRS_ENABLE_OSEKOS )
 #error "This HW file works only with osCAN emulation within CANoe!"
#endif
/*
 * Description: The BrsOsek header provides all the necessary interfaces to
 *              the OSEK OS support module. Please refer to the BrsOsek
 *              module for details of the supported features.
 *              This file is part of the BRS.
 */
#include "BrsOsek.h"

/*
 * Description: Due to this "platform" is always osCAN/CANoe, the OSEK header
 *              will be needed to provide access to e.g. the environmental
 *              variables for LEDs and switches.
 */
#if defined( VGEN_ENABLE_IF_ASRIFCAN )
#  include "os.h"
#else
#  include "osek.h"
#endif


#if defined( VGEN_ENABLE_CAN_DRV )
# if defined ( VGEN_ENABLE_IF_ASRIFCAN )
#  include "CanProto.h"
# else
#  include "can_inc.h"
# endif
#endif

/******************************************************************************
 * Version check
 ******************************************************************************/
#if defined( C_KOMMENTAR_VECTOR )
 /* CANbedded developers: Change the version numbers as specified for CANbedded modules. The
  * first release of a file should have the version 0x0100 and bugfix version 0x00. Do not 
  * forget to change the version number in the H file, too!
  */
#endif
#if( BRSHW_VERSION != 0x0106 )
  #error "Header and source file are inconsistent!"
#endif
#if( BRSHW_BUGFIX_VERSION != 0x06)
  #error "Different versions of bugfix in Header and Source used!"
#endif


/******************************************************************************
 * BRS configuration check
 ******************************************************************************/
#if defined( C_KOMMENTAR_VECTOR )
 /* CANbedded developers: Add your compiler specific checks here. */
#endif
#if defined( C_COMP_ANSI_CANOE )
#else
#error "Unknown compiler specified!"
#endif


/*******************************************************************************
 * Local defines
 *******************************************************************************/
#if defined( C_KOMMENTAR_VECTOR )
 /* CANbedded developers: All hardware and compiler specific defines, ports and values
  * necessary for the BRS handling are defined here. It is also possible to include
  * an compiler specific header instead of defining the settings here, but this is
  * not recommended due to possible version cnflicts with different compilers. The 
  * whole section is addressed to get access to the timer for the BRS base time 
  * handler, the time measurement ports, the LED and button ports and the transceiver
  * ports. If necessary, also registers for e.g. PLL access are to be defined, too. 
  */
#endif


/*******************************************************************************
 * Global variables
 *******************************************************************************/
 

/*******************************************************************************
 * Global const variables
 *******************************************************************************/
/** 
 * @var kBrsMainMainVersion
 *      Stores the BCD coded main-version of this file.
 */
/**
 * @var kBrsMainSubVersion 
 *      Stores the BCD coded sub-version of this file.
 */
/** 
 * @var kBrsMainBugfixVersion 
 *      Stores the BCD coded release-version of this file.
 */
vuint8 MEMORY_ROM kBrsHwMainVersion   = (vuint8)(BRSHW_VERSION >> 8);
vuint8 MEMORY_ROM kBrsHwSubVersion    = (vuint8)(BRSHW_VERSION & 0xFF);
vuint8 MEMORY_ROM kBrsHwBugfixVersion = (vuint8)(BRSHW_BUGFIX_VERSION);



/*******************************************************************************
 * Local variables and local HW register
 *******************************************************************************/
/**
 * @var bBrsHwIntDiCounter
 *      Count number of nested calls to BrsHwDisableInterrupt
 * 
 * This counter is used to count the number of nested calls to disable and restore
 * the state of the global INT enable bit. Please note: This variable is used only
 * in this file. Due to this variable being also accessed in assembler context, it
 * must not be "static" to prevent the compiler from changing the name into a local label.
 *
 * If no BrsHwDisableInterrupt is called and INT is allowed by the BRS, its value is
 * zero. If it is greater than zero, INT is locked by the BRS interrupt control API.
 */
#if defined( C_KOMMENTAR_VECTOR )
 /* CANbedded developers: This definition is hardware independent and must not be changed. */
#endif
MEMORY_NEAR vuint8 bBrsHwIntDiCounter;
 
/**
 * @var bBrsHwRegisterCCR
 *      This variable is used to store the state of the CCR register at
 *      the first call of BrsHwDisableInterrupt till the last nested call
 *      of BrsHwRestoreInterrupt.
 *
 * @attention   This variable is used only in this file. Due to it 
 *              is also access in assembler context, it must not be "static" to
 *              prevent the compiler changing the name in a local label.
 */
vuint8 bBrsHwRegisterCCR;


/*******************************************************************************
 *Timer control for "Free Running Timer" based time measurement support
 ******************************************************************************/
/* None used */

/*******************************************************************************
 * Timer control for 'FakeOS' 1ms time base generation
 ******************************************************************************/
/* None used */

/*******************************************************************************
 * Controller configuration registers
 ******************************************************************************/
/* None used */

/*******************************************************************************
* Local const variables
*******************************************************************************/
/* None used */

/*******************************************************************************
* Prototypes of local functions 
*******************************************************************************/
/* Not used */

/*******************************************************************************
* Function definitions
*******************************************************************************/
#if defined( C_KOMMENTAR_VECTOR )
 /* CANbedded developers: The handling in the functions below is described within the code
  * areas, please refer to the comments. */
#endif

/*******************************************************************************/
/**
 * @brief Hardware Initialization Routine
 *        Initialize hardware specific functions like PLL, power, IO-ports and other
 *        basic features.
 *
 * @pre   Must be called first of all init routines at power on
 *
 * @post  System is up and working
 */
void BrsHwHardwareInitPowerOn( 
  void 
)
{
  /*****************************************************************************
   * Initialize basic system and chip features here
   ****************************************************************************/
  /* No clock or PLL settings for CANoe necessary. */
  /* Power supply settings for CANoe necessary. */
  /* Watchdog (COP) not used */

#if (((defined CAN_DRIVER_VERSION) && (CAN_DRIVER_VERSION < 0x111)) && \
     ((defined CANOEAPI_VERSION) && (CANOEAPI_VERSION >= 106)))
#  if defined (C_ENABLE_RESET_CAN_BUSOFF) || defined (C_DISABLE_RESET_CAN_BUSOFF)
  extern V_MEMROM0 V_MEMROM1 vuint8* V_MEMROM1 V_MEMROM2 CanBusName[kCanNumberOfChannels];
  vuint8 ch;
  for (ch = 0; ch<kCanNumberOfChannels; ch++) {
    CANoeAPI_MapChannel(CanBusName[ch], CANOEAPI_BUSTYPE_CAN, ch);
  }    
#  else
  CANoeAPI_MapChannel("CAN", CANOEAPI_BUSTYPE_CAN, 0);
#    pragma message( "CAN channel 0 is mapped to \"CAN\"" )
#    pragma message( "CANoe setup has to be adjusted properly or you have to map the channels in BrsMainInit.inc manually." )
#  endif /* defined (C_ENABLE_RESET_CAN_BUSOFF) || defined (C_DISABLE_RESET_CAN_BUSOFF) */
#endif /* CAN_DRIVER_VERSION < 0x111 */


  
  /*****************************************************************************
   * Initialize module variables (without INT handling variables!)
   ****************************************************************************/
  /* none */


  /*****************************************************************************
   * Initialize LEDs
   ****************************************************************************/
  #if defined( C_KOMMENTAR_VECTOR )
  /* CANbedded developers: Assign the LED ports to output and switch the LEDs to off.
   * If no LEDs are available, add an comment. */
  #endif
  CANoeAPI_PutValueInt("EnvLed1", BRSHW_LED_OFF);
  CANoeAPI_PutValueInt("EnvLed2", BRSHW_LED_OFF);
  CANoeAPI_PutValueInt("EnvLed3", BRSHW_LED_OFF);
  CANoeAPI_PutValueInt("EnvLed4", BRSHW_LED_OFF);
  CANoeAPI_PutValueInt("EnvLed5", BRSHW_LED_OFF);
  CANoeAPI_PutValueInt("EnvLed6", BRSHW_LED_OFF);
  CANoeAPI_PutValueInt("EnvLed7", BRSHW_LED_OFF);
  CANoeAPI_PutValueInt("EnvLed8", BRSHW_LED_OFF);

  /*****************************************************************************
   * Set one LED 
   ****************************************************************************/
  BrsHwSetLed(BRSHW_LED_SYSTEM_OK, BRSHW_LED_ON);

  /*****************************************************************************
   * Initialize KEYs
   ****************************************************************************/
  #if defined( C_KOMMENTAR_VECTOR )
  /* CANbedded developers: Assign the button ports to input. If no LEDs are 
   * available, add an comment. */
  #endif

  /*****************************************************************************
   * Time measurement support; initialization starts here
   ****************************************************************************/
  #if defined ( BRS_ENABLE_TIMETEST )
    #if defined( BRS_ENABLE_TIMETEST_SCOPE ) || defined( BRS_ENABLE_TIMETEST_PC )
      #error "Wrong timing setup: Scope and Timetest PC not supported"
    #else 
      #if defined( BRS_ENABLE_TIMETEST_FREETIMER )
        #error "Wrong timing setup: Scope and Timetest PC currently not supported (TODO)"
      #else
        #error "Wrong timing setup: No timing measurement method is defined"
      #endif      
    #endif
  #endif
}


/*******************************************************************************/
/**
 * @brief Initialization Routine for the time base clock
 *        Initialize timer generating the 1ms interrupt when there is no osCAN support.
 *
 * @pre   Must be called at power on, interrupt vector for 1ms interrupt must be correctly set.
 *
 * @post  Timenbase is initialized
 */
void BrsHwTimeBaseInitPowerOn(
  void
) 
{
  #if defined( BRS_ENABLE_OSEKOS )
  /* This function is not necessary, if an OSEK OS is running! */
  #else
  #endif
}


#if defined( BRS_ENABLE_OSEKOS )
/* This ISR function is not necessary if the OSEK OS is used! */
#else /*BRS_ENABLE_OSEKOS*/
/*******************************************************************************/
/**
 * @brief Interrupt Service Routine for the 1ms time base interrupt
 *        Increment the one millisecond timer flag and clear the interrupt flag in the
 *        corresponding register.
 *
 * @pre   Interrupt vector for 1ms interrupt must be correctly set.
 */
/*******************************************************************************/
void BrsHwTimeBaseInterrupt(
 void
)
{
}
#endif /*BRS_ENABLE_OSEKOS*/


#if defined( VGEN_ENABLE_LIN_DRV ) 
/*******************************************************************************/
/**
 * @brief Interrupt Service Routine for LIN wakeup
 *        If the node should be waked up via LIN, this port has to be
 *        connected to the LIN bus. A wakeup interrupt is called for
 *        detected communication. It is the job of the application to 
 *        start the LIN communication.
 *
 * @attention This service is currently not supported.
 *
 * @pre       Interrupt vector for the LIN wakeup interrupt must be correctly set.
 */
/*******************************************************************************/
void BrsHwLinWakeupInterrupt(
 void
)
{
  /* Inform the LIN application about the wakeup event. */
}
#endif /*VGEN_ENABLE_LIN_DRV*/

#if defined( VGEN_ENABLE_LIN_DRV ) 
/*******************************************************************************/
/**
 * @brief Interrupt Service Routine for LIN interrupt
 *        This service is currently not supported.
 *
 * @pre   Interrupt vector for the LIN interrupt must be correctly set.
 */
/*******************************************************************************/
void BrsHwExtLinInterrupt(
 void
)
{
}
#endif /*VGEN_ENABLE_LIN_DRV*/


/*******************************************************************************/
/**
 * @brief Interrupt Service Routine for unexpected interrupts
 *        This Interrupt Service Routine is called whenever an unexpected 
 *        interrupt occurrs.Call the main exception handler, which will lead to 
 *        a stall of the whole system
 */
/*******************************************************************************/
void BrsHwDummyInterrupt(
 void
)
{
  #if defined( C_KOMMENTAR_VECTOR )
  /* CANbedded developers: Do not change the call to the exception handler here. */
  #endif
  BrsMainExceptionHandler(kBrsInterruptHandlerNotInstalled, BRSERROR_MODULE_BRSHW, (vuint16)(__LINE__));
}


/*******************************************************************************/
/**
 * @brief Routine to disable all interrupts during power on.
 *        Initialize interrupt handling and disable all interrupts.
 *
 * @pre   Must be called first before calling any init routine.
 */
/*******************************************************************************/
void  BrsHwDisableInterruptAtPowerOn( 
  void 
)
{
  #if defined( C_KOMMENTAR_VECTOR )
  /* CANbedded developers: Do not change the assignment of 0 to bBrsHwIntDiCounter here. */
  #endif
  bBrsHwIntDiCounter = 0;

  #if defined( C_KOMMENTAR_VECTOR )
  /* CANbedded developers: Add code to disable the global interrupt here */
  #endif
}


/*******************************************************************************/
/**
 * @brief Routine to enable all interrupts during power on.
 *        Enable all interrupts.
 *
 * @pre   Must be called when all initializations are done
 */
void  BrsHwEnableInterruptAtPowerOn( 
  void 
)
{
  #if defined( C_KOMMENTAR_VECTOR )
  /* CANbedded developers: Add code to enable the global interrupt here */
  #endif
}

/*******************************************************************************/
/**
 * @brief Routine to disable all interrupts
 * 
 * Disable all interrupts and store the state of the global INT flag into a local
 * variable when being called during "normal" operation. This state will be restored
 * when returning to normal operation.
 *
 * When detecting nested calls, i.e. one interrupt interrupts another, the state
 * needs not be saved.
 */
void BrsHwDisableInterrupt(
 void
)
{
  #if defined( C_KOMMENTAR_VECTOR )
  /* CANbedded developers: Do not forget to check bBrsHwIntDiCounter here! */
  #endif
  /* No check for "overrun" of nested INT lock counter is performed, due to more
  *  than 255 nested calls to BrsHwDisableInterrupt are very unlikely. */
  #if defined( C_KOMMENTAR_VECTOR )
  /* CANbedded developers: Do not remove the time stamp call below! */
  #endif
  bBrsHwIntDiCounter++;
}


/*******************************************************************************/
/**
 * @brief Routine to enable all interrupts
 * 
 * Restore the state of the global INT flag and enable all interrupts when returning
 * to "normal" operation.
 *
 * When returning from a nested call, the state must not be restored. When trying to
 * restore more often than having disabled, an exception will be raised and the system
 * will block.
 */
void BrsHwRestoreInterrupt(
 void
)
{
  #if defined( C_KOMMENTAR_VECTOR )
  /* CANbedded developers: Do not forget to check bBrsHwIntDiCounter here! */
  #endif
  /* Check for illegal call of BrsHwRestoreInterrupt. If this function is called 
  *  to often, the INT lock works incorrect. */
  if( bBrsHwIntDiCounter==0)  {
    BrsMainExceptionHandler( kBrsIllegalInterruptRestoration, BRSERROR_MODULE_BRSHW, (vuint16)(__LINE__) );
  }
  bBrsHwIntDiCounter--;

  #if defined( C_KOMMENTAR_VECTOR )
  /* CANbedded developers: Do not remove the time stamp call below! */
  #endif
}


/*****************************************************************************/
/**
 * @brief Routine to software reset the system
 * 
 * Issue a software reset, i.e. jump to startup code.
 * 
 * This service is currently not supported.
 */
/*****************************************************************************/
void BrsHwSoftwareResetECU( 
  void 
)
{
}


/*******************************************************************************/
/**
 * @brief Routine to control the software programmable LEDs on the EVA board
 * Switch a programmable LED on or off. BRS supports up to 8 LEDs depending on the
 * EVA board.
 *
 * @param[in] LedNumber may take any value in the range [0..7]. LED 0 is 
 *            reserved for system use, i.e. blinking to indicate a working system.
 * @param[in] NewState may take one of the predefined values BRSHW_LED_ON and 
 *            BRSHW_LED_OFF.
 */
void BrsHwSetLed(
  vuint8 LedNumber, 
  vuint8 NewState
)
{
  #if defined( BRS_ENABLE_SUPPORT_LEDS )
  switch( LedNumber ) {
    case 1:
      CANoeAPI_PutValueInt("EnvLed2", NewState);
      break;
    case 2:
      CANoeAPI_PutValueInt("EnvLed3", NewState);
      break;
    case 3:
      CANoeAPI_PutValueInt("EnvLed4", NewState);
      break;
    case 4:
      CANoeAPI_PutValueInt("EnvLed5", NewState);
      break;
    case 5:
      CANoeAPI_PutValueInt("EnvLed6", NewState);
      break;
    case 6:
      CANoeAPI_PutValueInt("EnvLed7", NewState);
      break;
    case 7:
      CANoeAPI_PutValueInt("EnvLed8", NewState);
      break;
    default:
      CANoeAPI_PutValueInt("EnvLed1", NewState);
      break;
  }
  #else
    LedNumber = LedNumber;
    NewState = NewState;
  #endif /*BRS_ENABLE_SUPPORT_LEDS*/
}


/*******************************************************************************/
/**
 * @brief Routine to check the state of all keys on the EVA board
 *
 * Check the state of all supported keys. Interpret the return value in the following
 * way:
 * - If key A is being pressed, bit 0 of the return value is 1, otherwise 0.
 * - If key B is being pressed, bit 1 of the return value is 1, otherwise 0.
 * - If key C is being pressed, bit 2 of the return value is 1, otherwise 0.
 * - If key D is being pressed, bit 3 of the return value is 1, otherwise 0.
 *
 * @retval Current state of all switches
 *
 * @attention This service is not supported for this platform and/or EVA board.
 */
vuint8 BrsHwCheckAllKeys(
  void
)
{
  #if defined( BRS_ENABLE_SUPPORT_KEYS )
  return CANoeAPI_GetValueInt("EnvKeyA") << 0 | 
         CANoeAPI_GetValueInt("EnvKeyB") << 1 | 
         CANoeAPI_GetValueInt("EnvKeyC") << 2 | 
         CANoeAPI_GetValueInt("EnvKeyD") << 3;
  #else
  return 0;
  #endif /*BRS_ENABLE_SUPPORT_KEYS*/
}


/*******************************************************************************/
/**
 * @brief Routine to check the state of key A on the EVA board
 * Check the state of key A, if supported. If key A is being pressed, the return
 * value is 1, otherwise 0.
 *
 * @retval Current state of the switch
 *
 * @attention This service is not supported for this platform and/or EVA board.
 */
vuint8 BrsHwCheckKeyA(
  void
)
{
  #if defined( BRS_ENABLE_SUPPORT_KEYS )
  return CANoeAPI_GetValueInt("EnvKeyA");
  #else /*BRS_ENABLE_SUPPORT_KEYS*/
  return 0;
  #endif /*BRS_ENABLE_SUPPORT_KEYS*/
}


/*******************************************************************************/
/**
 * @brief Routine to check the state of key B on the EVA board
 * Check the state of key B, if supported. If key B is being pressed, the return
 * value is 1, otherwise 0.
 *
 * @retval Current state of the switch
 *
 * @attention This service is not supported for this platform and/or EVA board.
 */
vuint8 BrsHwCheckKeyB(
  void
)
{
  #if defined( BRS_ENABLE_SUPPORT_KEYS )
  return CANoeAPI_GetValueInt("EnvKeyB");
  #else /*BRS_ENABLE_SUPPORT_KEYS*/
  return 0;
  #endif /*BRS_ENABLE_SUPPORT_KEYS*/
}


/*******************************************************************************/
/**
 * @brief Routine to check the state of key C on the EVA board
 * Check the state of key C, if supported. If key C is being pressed, the return
 * value is 1, otherwise 0.
 *
 * @retval Current state of the switch
 *
 * @attention This service is not supported for this platform and/or EVA board.
 */
vuint8 BrsHwCheckKeyC(
  void
)
{
  #if defined( BRS_ENABLE_SUPPORT_KEYS ) 
  return CANoeAPI_GetValueInt("EnvKeyC");
  #else /*BRS_ENABLE_SUPPORT_KEYS*/
  return 0;
  #endif /*BRS_ENABLE_SUPPORT_KEYS*/
}



/*******************************************************************************/
/**
 * @brief Routine to check the state of key D on the EVA board
 * Check the state of key D, if supported. If key D is being pressed, the return
 * value is 1, otherwise 0.
 *
 * @retval Current state of the switch
 *
 * @attention This service is not supported for this platform and/or EVA board.
 */
vuint8 BrsHwCheckKeyD(
  void
)
{
  #if defined( BRS_ENABLE_SUPPORT_KEYS ) 
  return CANoeAPI_GetValueInt("EnvKeyD");
  #else /*BRS_ENABLE_SUPPORT_KEYS*/
  return 0;
  #endif /*BRS_ENABLE_SUPPORT_KEYS*/
}


/*******************************************************************************/
/**
 * @brief Routine to measure the runtime of 100 NOP instructions
 *        This API is used for the BRS time measurement support to get a default
 *        time value for all measurments with this platform to be able to 
 *        compare time measurements on different dates based on this time result.
 *
 * @pre   Support for runtime measurement has to be enabled on the GenTool's BRS page.\n
 *        A valid measurement method has to be chosen in the BrsTimeGen tool.\n
 *        This file must have been organified with the option measure=1 in the [SPECIAL] section.
 */
void BrsHwTime100NOP(
  void
)
{
  BrsHwDisableInterrupt();
  #if defined( C_KOMMENTAR_VECTOR )
  /* CANbedded developers: Add the equivalent to 100 NOP commands here and check that they 
   * are not removed by the optimizer! */
  #endif

  /* CANoe version of BRS does not support the 100 NOP measurement feature! */  

  BrsHwRestoreInterrupt();
}

/*******************************************************************************
* Transceiver Handling
*******************************************************************************/

/*******************************************************************************
* En Port
*******************************************************************************/

/*******************************************************************************/
/**
 * @brief Routine to set transceiver port RS to high
 *        Set the transceiver port to high. 
 *
 * @param[in] channel describes the logical CAN channel index.
 *
 * @attention Currently there is no transceiver functionality implemented.
 *
 * @pre   CAN bus is used
 */
/*******************************************************************************/
void BrsHwSetTrcvEnPortToHigh(
  vuint8 channel
)
{
}

/*******************************************************************************/
/**
 * @brief Routine to set transceiver port RS to low
 *        Set the transceiver port to low. 
 *
 * @param[in] channel describes the logical CAN channel index.
 *
 * @attention Currently there is no transceiver functionality implemented.
 *
 * @pre   CAN bus is used
 */
/*******************************************************************************/
void BrsHwSetTrcvEnPortToLow(
  vuint8 channel
)
{
}

/*******************************************************************************/
/**
 * @brief Routine to set transceiver port RS' mode
 *        Set the transceiver port RS' mode. 
 *
 * @param[in] channel describes the logical CAN channel index.
 *
 * @attention Currently there is no transceiver functionality implemented.
 *
 * @pre   CAN bus is used
 */
/*******************************************************************************/
void BrsHwSetTrcvEnPortMode(
  vuint8 channel
)
{
}

/*******************************************************************************/
/**
 * @brief Routine to set transceiver port RS' direction
 *        Set the transceiver port RS' direction. 
 *
 * @param[in] channel describes the logical CAN channel index.
 *
 * @attention Currently there is no transceiver functionality implemented.
 *
 * @pre   CAN bus is used
 */
/*******************************************************************************/
void BrsHwSetTrcvEnDirection(
  vuint8 channel
)
{
}

/*******************************************************************************
* Stb Port
*******************************************************************************/

/*******************************************************************************/
/**
 * @brief Routine to set transceiver port Stb to high
 *        Set the transceiver port Stb to high. 
 *
 * @param[in] channel describes the logical CAN channel index.
 *
 * @attention Currently there is no transceiver functionality implemented.
 *
 * @pre   CAN bus is used
 */
/*******************************************************************************/
void BrsHwSetTrcvStbPortToHigh(
  vuint8 channel
)
{
}

/*******************************************************************************/
/**
 * @brief Routine to set transceiver port Stb to low
 *        Set the transceiver port Stb to low. 
 *
 * @param[in] channel describes the logical CAN channel index.
 *
 * @attention Currently there is no transceiver functionality implemented.
 *
 * @pre   CAN bus is used
 */
/*******************************************************************************/
void BrsHwSetTrcvStbPortToLow(
  vuint8 channel
)
{
}

/*******************************************************************************/
/**
 * @brief Routine to set transceiver port Stb's mode
 *        Set the transceiver port Stb's mode. 
 *
 * @param[in] channel describes the logical CAN channel index.
 *
 * @attention Currently there is no transceiver functionality implemented.
 *
 * @pre   CAN bus is used
 */
/*******************************************************************************/
void BrsHwSetTrcvStbPortMode(
  vuint8 channel
)
{
}

/*******************************************************************************/
/**
 * @brief Routine to set transceiver port Stb's direction
 *        Set the transceiver port Stb's direction. 
 *
 * @param[in] channel describes the logical CAN channel index.
 *
 * @attention Currently there is no transceiver functionality implemented.
 *
 * @pre   CAN bus is used
 */
/*******************************************************************************/
void BrsHwSetTrcvStbDirection(
  vuint8 channel
)
{
}

/*******************************************************************************
* Err Port
*******************************************************************************/

/*******************************************************************************/
/**
 * @brief Routine to retrieve the transceiver port Err's value
 *        Retrieve the transceiver port Err's value. 
 *
 * @param[in] channel describes the logical CAN channel index.
 *
 * @retval If the return value is 1, the Err pin is set to high. If the return 
 *         value is 0, the Err pin is set to low.
 *
 * @attention Currently there is no transceiver functionality implemented.
 *
 * @pre   CAN bus is used
 */
/*******************************************************************************/
vuint8 BrsHwGetTrcvErrPortValue(
  vuint8 channel
)
{
  return 0;
}

/*******************************************************************************/
/**
 * @brief Routine to set transceiver port Err's mode
 *        Set the transceiver port Err's mode. 
 *
 * @param[in] channel describes the logical CAN channel index.
 *
 * @retval If the return value is 1, the Err pin is set to high. If the return 
 *         value is 0, the Err pin is set to low.
 *
 * @attention Currently there is no transceiver functionality implemented.
 *
 * @pre   CAN bus is used
 */
/*******************************************************************************/
void BrsHwSetTrcvErrPortMode(
  vuint8 channel
)
{
}

/*******************************************************************************/
/**
 * @brief Routine to set transceiver port Err's direction
 *        Set the transceiver port Err's direction. 
 *
 * @param[in] channel describes the logical CAN channel index.
 *
 * @retval If the return value is 1, the Err pin is set to high. If the return 
 *         value is 0, the Err pin is set to low.
 *
 * @attention Currently there is no transceiver functionality implemented.
 *
 * @pre   CAN bus is used
 */
/*******************************************************************************/
void BrsHwSetTrcvErrDirection(
  vuint8 channel
)
{
}


/************   Organi, Version 3.6.8 Vector-Informatik GmbH  ************/
